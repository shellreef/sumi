TO DO
$Id$

* Files don't resume correctly if start transfer, stop it, then resume it
  while the server is still sending (hasn't found out client died yet); server
  tries multicast--reusing the existing transfer, but causes corruption. As
  a workaround for now, wait until client stops previous transfer before
  resuming--it works fine then, as far as I can tell.
* Make sure files transfer correctly!
* Fix bug, evident with modtor, where multicast is erroneously detected,
  causing transfer to freeze on "Authenticating" after requests from clients
  to the same address, but with different nicks (always different in modtor!)
   Maybe disable multicast for now?
* Fix bug, not sure what causes, but I'm trying to download #1 and it has one
  remaining lost packet, but it just times out every time when resuming it.
  Looks like sumiget is trying to ack to get more with a plain "n" but there
  are no more non-lost packets for the server to continue sending! Server just
  sends a zero-byte packet; but there are still gaps in the file!

* Make a convenient way to invoke SUMI from the web, like .torrent files.
  Initial idea was a sumi:transport/user/file URL, but creating a new MIME
  type and setting the appropriate handler seems more portable, but is it 
  worth it for a very small file?
* Switch to standard 'logger' module for logging, if its worth it.
* Look into ctypes instead of SWIG for LibTomCrypt, might be easier(no amd64?)
* Migrate from Python 2.3 to 2.4, and use os.urandom...
* Look into FSP - http://cvs.sourceforge.net/viewcvs.py/fsp/fsp/INFO?view=auto
  it is slower than TCP, but can adapt very quickly to changing conditions
  see also: http://fsp.sourceforge.net/faq/index.html . its based on UDP, may
  be usable for a control algorithm. Also reinstate TFTP mode.
* Pcap: find out if interface is down. If not, refuse to use it.
* Auto-configure many options:
 - If only one network interface up, use it (for 'interface')
 - Use the IP of the interface, if nonroutable, use get_default_ip w/ warning
 - Use the MTU of the interface, or guess it based on datalink  
 - For "pcap" dchanmode, use the MAC of the interface for src_mac
 WMI can handle this on Win32, but currently commented out. TODO: look at it
DONE * Work on modtor.py, and have a flag for secure/insecure transports,
     and if insecure, automatically enable crypt_req if crypto enabled, other-
     wise can rely on transport to provide the transport security, but always
     enable crypt_data if user wants crypto. 
* Find out why I have config.html,faq.html in . and doc/, & whats better
  DONE with faq.html and config.html.
* DONE--modtor Investigate tor (tor.eff.org) for a transport
* Investigate AIM over HTTP proxy
* Use LibTomCrypt for everything after wrapping it for Python

* DONE Migrate from wxPythonWIN32-2.4.2.4-Py23 to wxPython 2.6, and Python 2.4
* DONE Get crypt_data working! Currently corrupts last packet.
* DONE
  Make client verify nonce from server, and make server send hash of nonce
  in new_prefix of auth packet, which will then be used for data prefix.
  Or maybe add a new, larger header in auth packet for the hash, >24-bit.
  This is NECESSARY to protect against MITM.
* DONE Encrypt auth & auth packet 

* (No) crypto: use SSLCrypto library, generate key, k.encStart() then
  k.encNext(data). First call, returns 1544-byte beginning, with some 
  bencoded data, but subsequent k.encNext(data)'s return n-byte strings!
  This way, each packet can be encrypted 1:1, with no increase in size; just
  have to find a place for the initial 1544 bytes (for 2048-bit key). However,
  all data before a packet must be received in order to decrypt it (no gaps).
* multiple transfers per person, with only one auth
* sumi dir!
* Get sumiget.py standalone working again. The server works standalone but
  not everyone wants to use sumigetw to run the GUI.
* GUI to create sumiserv.cfg easily--have a simple console tab in
  "Server" as of 20050706, but need configuration options. Seemless.
* Find out why "Exit Now" is delayed when uncompiled, but not when py2exe'd
* Generally clean up the code
* Real documentation, not just the "mini-howtos"; autogenerated docs too
* Different sharing strategies:
 - iroffer/xdcc - have this now
 - file library, browsable, sumi dir
 - explicit send, client initiates send (as on IM programs), groups like AG?
* Investigate using dummy interface to spoof IP, see if its worthwhile
  Larytet of Rodi suggested this; and the infamous ES5 also used it, but how
  quickly can addresses be changed?
DONE * Re-do encryption; use public key crypto, automatic
? - maybe integrate what I learned with IMOTP back into SUMI
DONE  - symmetric cryptography; (but not done for passworded servers)
DONE - Get rid of all the cryptography junk now

* Other transfer modes--support old TFTP-style, new ack-less FEC
* Multicasting support
  - need to continously transmit (data carousel) file over and over, until
    all the users in casts[address] have received it
DONE  - need to have a way to not excessively request loss packets that will be
    resent when next file starts sending, i.e.,:
     if excessive lost packets:
         if multicasting: ignore
         else: stop, too much
    what is "excessive" anyway? rethink this
  - already have a casts[] hash, the index being the multicast/bcast address,
    and the entries a hash where the keys are the nicknames (values=1)
  - need to do IGMP commands, join group etc. in sumiget for mcast
  - test with bcast, and mcast on local network
* Adjust requested bandwidth based on actual bandwidth
* Resume transfer in sumiget (context menu option)--currently broken
* Checksumming over whole file, not just each packet.
  The new AONT module will kind of do this.
* One-time pad crypto -- could be useful for server anonymous to network,
  but not to the intended client that possesses the pad.
* Secure the prefix? It reveals the streams, its not all random data. How?

* (no?) SOCKS proxy, to allow any TCP/UDP service to be used with SUMI
  (like tor - http://freehaven.net/tor/ - but without the onion routing)
  Feasible? More focused on bulk data transfer.
* DONE
  Pre-auth encryption, so covert (optional) + data chan can be encrypted. This
  way the IP can be encrypted, so IRC net doesn't need to encrypt and IRC 
  admins can't track; only UDP spoofers can. (Also it will encrypt prefix, so
  the UDP stream cannot be associated with it easily.)
  ???: What did I mean by the last two sentences?
  pycrypto: http://www.amk.ca/python/code/crypto.html pycrypto.sf.net
   ezpycrypto, yawpycrypto.sf.net
* DONE Public key asymmetric crypto -- EC-DH for shorter keys
* DONE -- new dchanmode, "pcap" to send link-layer frames
  For transfer to hosts without routers in between, Libpcap spoof MAC Ethernet
  address. Universities for example may have networks structured like this.
* DONE Fill in UDP checksum! Invalid UDP checksums should be tossed, act as if
  never received them and they will be resent. (The stack discards them.)
* DONE Pause/Cancel transfers in sumiget (Abort)
* DONE Two-way transport communication. (recvmsg)
* DONE sumiserv.py transport integration (irclib & aim)
* DONE Resuming.When quitting, or crashes, or when each packet received,SAVE the
  list of the missed packets before it, and the last packet received. From this
  information, the gaps can be filled and the transfer complete for resuming.
* DONE Fix file transfer progres; base it on packets /RECEIVED/, not last seqno
* DONE Fix the xchat transport, somehow it crashes now? 
* DONE Fix overlong transport messages, IRC xchat sends 452.
* DONE Arbitrary ICMP packet data channel type, echo reply very promising 
* DONE Realistically, the rawproxd model we are currently using will not work.
  The program will close after one connection.  CPPSocket library has
  implemented a TCPThreaded server.  It spawns a thread per connection and
  is probably the end goal.  -thebeta3
  jc: Looping nonforking client in pure C implemented (rawproxd.c)

* (no) Multisourcing for faster transfers? Doesn't look too secure. Faster speeds
  are good, but for each source, the IP is revealed. Better to only d/l from
  sender the client explicitedly requested from than a whole amalgam of hosts
  the client didn't implicitedly trust.

From briangrunt on Feb3rd,2004 
http://www.zeropaid.com/bbs/showthread.php?t=17969
I don't know how to contact anyone directly and so will post my idea here.

Mute tries to achieve privacy by avoiding direct connections. I read the "how it works'' doc, and it does seem that mute should successfully keep users safe from lawsuits--however, it does it at the cost of speed and possibly other features.

I'm no network expert, but would it be possible to make an asymmetric connection protocol? In essence, search/download requests would go out on the network, not trying to hide the IP of the person who wants to download. This is because it's relatively safe to download--as I understand it, some place or other even deemed it legal.

When the user finds a download they want, sources initiate a connection to the destination computer, always spoofing/leaving the return IP address blank. In other words, the source can send directly to the destination. But since the destination does not know the IP of the source, it would instead route ACK or other network control signals, Mute-style, through the network. This would greatly ease the burden on the network, since ACK and other network control signals are very lightweight, low bandwidth, especially compared to what mute currently has to route through.

Of course, in order for this to work, spoofing must work correctly. Sadly, as I understand it, most/many types of internet service allow the ISP to know who really sent a packet even if the return address is spoofed or blank. They can theoretically then insert the correct return address before routing the packet on. The question then, is how often they do this in practice--and I don't know the answer to that question. Each host, though, should be able to perform a simple test to see whether they can successfully perform spoofing, maybe through a simple series of pings perhaps.

So, what do you think of this idea?
> exactly like SUMI! i really should integrate MUTE!

From tr1sk Eddie Sohn on mute-net.sf.net
*http://sourceforge.net/forum/forum.php?thread_id=1017118&forum_id=283651 
*a proposal on MUTE almost exactly like SUMI, a subset of

The key strength of MUTE is its ability to offer two-way secure anonymous
communication. Unfortunately, this comes at the cost of download speed. 
> IRC does too if netmask spoofed, but MUTE would be better, if slower
By routing every file through multiple MUTE nodes, many users have to pay for
one user downloading a file. Also, download speeds are limited by the weakest 
link in the chain. Since upload speeds are often lower than download speeds, performance is dropped even further. 
> Yeah, its like i2p (iip file transfer, very slow)
In real world use, this leads to an environment were even the highest 
bandwidth users are downloading files at modem speeds. Even worse, as more 
users start joining this network very little bandwidth will be available to 
enable long-term scalability.

A powerful solution is available if the file sender is allowed to know the 
recipients IP address. When a user requests a file, he includes his machines 
encrypted IP address in the message. 
> sumi send, but how can the IP be encrypted? Oh - Public Key Encryption.
> Recipient would need to send its pubkey, and sender send pubkey, client
> encrypts w/ its privkey, sender encrypts with its privkey. Secure! Like an
> OTP, but in theory breakable, and the covert channel doesn't have to be
> secure.
The sender can then use IP address spoofing to transfer the file to the recipient. Throughout the transmission, the senders true identity remains protected. This offers very fast one-way secure communication from the sender to the recipient. 
> The essense of SUMI!
Unfortunately, files cant be sent via the internet with only one-way communication due to the lossy nature of internet packets. Luckily, MUTE already offers two-way secure communication with limited bandwidth. Now the file recipient can send back packet acknowledgements to the sender through MUTE without ever knowing his IP address. This places minimal load on the MUTE network since each packet receipt can be acknowledged with a single bit, and acknowledgements can be bundled and sent out with long time intervals.
> Exactly what I came up with.

There are four problems with this solution. The first is the sharers knowledge of the recipients IP address. The sender (X) now has the recipients (Y) virtual MUTE address and IP address. If X were an adversary, he could use this information to his advantage.
>Yes, a real problem with SUMI.
For a limited time, any shared file hosted by Ys virtual address can be mapped to his IP address by X. If X were to search and find a file hosted by Y, He would be able to map Ys IP address to the file. Fortunately, MUTE has a very elegant solution to this problem. There is no limit to the number of virtual addresses that can be mapped to each user. User Y can be given two virtual addresses: A and B. He can respond to all sharing queries with address A and search for files with address B. Now user X can only map address B to an IP address. When searching for files hosted by virtual address B, he will find none. All those files are being shared under the virtual address A.

The second problem is the ability to successfully transmit spoofed packets. Modifying the IP headers on packets via raw sockets is only allowed on Windows 2000/XP and Linux/Unix. This could prohibit Windows 9x users from using the system. It appears compatibility could be added to older systems by using a library such as WinPcap (http://winpcap.polito.it/). 
> Maybe? Worth a try--SUMI doesn't use WinPcap yet.
Nevertheless, even if the packet is successfully transmitted by the sender, some routers may detect the spoofed packet and drop it. 
> Also a problem. Using IPs in same subnet or ISP helps a lot, but logins may
> prevent the spoofing. "Prefixes", like 4/24 for 4.0.0.0-4.255.255.255. 
Furthermore, if the sender uses a NAT router (those linksys and netgear boxes that are used to share an internet connection), it could modify the IP header, effectively unspoofing the packet. Unfortunately, I do not know enough about the underlying network protocols to definitively state whether spoofing can be made to work in these situations. Hopefully another developer with low level networking experience will have more to add on this topic.
> Also as far as I know it can't. These NATs forward IP packets, all which have
>IP addresses, so using another IP transport protocol won't help much. NATs do 
>it indiscriminately. The fix I've came up with is setting up a box as a NAT
>and operating on the NAT box itself, not behind it. NAT is evil, it prohibits
>communication! Could the NAT box's firmware be hacked to not change IPs that
>are not from the network. Maybe software NATs could forward packets from
>anywhere, but only change the source address if its from the local network.

The third problem is MAC addresses. Every Ethernet packet contains the intermediate source and destination MAC addresses. The source MAC address is modified on the packet each time it reaches a router; however, if the packet never hits a router, the users MAC address will be known by the receiver. The likelihood of a security breach here is very slim, since the sender and recipient would have to be on the same local network. This security problem would be unlikely to affect most Internet users; however, it could make using the program on large local networks, like universities, less secure. One potential solution would be to use the WinPcap library to create raw packets, which would allow the MAC addresses to be forged.
> Great idea, never thought of that. U's don't have routers everywhere. I
> considered this idea but saw no use of it, Universities are the use.

The final problem is firewalls. If a user is behind a firewall and is unable to open any ports, fast one-way communication cant be established between the sender and the receiver. [...] firewalled clients would not create the same unresponsive environment that plagued the Gnutella push style network. Firewalled users would not be able to download any files, and correctly configured users could download freely from both firewalled and non-firewalled users.
> Solution: ICMPs go through firewalls! Some at least. ICMP echo reply usu.
> does, otherwise every ping will time out. This is implemented in SUMI with
> the "e" (echo) mode right now, which bounces the packets of another host.
> Sending arbitrary type & code ICMPs would be much better. Need winpcap.

Another option is to have a middleman receive the file and give it to the user. For example, a firewalled MUTE node could ask one of its neighbors, all of whom must have their firewall open, to request the file and forward it to them. The contents of the transmission would be encrypted so that the middleman is unaware of the actual file or information being transferred. Lastly, if no other option is acceptable, this project could be forked into one that was firewall friendly and one that wasnt.
> I don't think thats such a good idea; too much bandwidth.

I hope this transfer method helps optimize MUTE. There are still questions that need to be answered before this theory is proven feasible. I have posted this message with the hope that other users will help resolve these issues and see this technology to fruition. Even if this method is never incorporated into MUTE, I hope it will help give new ideas to other developers. Once again, congratulations on a fantastic network design."
>

